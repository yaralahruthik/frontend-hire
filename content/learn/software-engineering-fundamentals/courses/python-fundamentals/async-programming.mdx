---
title: Async Programming
description: Asynchronous programming patterns in Python vs JavaScript.
---

## Basic Async Functions

<Tabs items={['Python', 'JavaScript/TypeScript']}>
<Tab value="Python">
```python
import asyncio

# Define async function
async def fetch_data():
    await asyncio.sleep(1)
    return "Data loaded"

# Call async function
async def main():
    result = await fetch_data()
    print(result)

# Run async function
asyncio.run(main())

# Or use event loop directly
loop = asyncio.get_event_loop()
loop.run_until_complete(main())
```
</Tab>
<Tab value="JavaScript/TypeScript">
```javascript
// Define async function
async function fetchData() {
  await new Promise(resolve => setTimeout(resolve, 1000));
  return "Data loaded";
}

// Call async function
async function main() {
  const result = await fetchData();
  console.log(result);
}

// Run async function (automatic)
main();

// Or use .then()
main().then(() => console.log("Done"));
```
</Tab>
</Tabs>

**Key Differences:**
- Python: must use `asyncio.run()` or event loop
- JavaScript: async functions run automatically
- Python: explicit event loop management
- JavaScript: built-in event loop
- Both use `async`/`await` keywords

## Promises vs Coroutines

<Tabs items={['Python', 'JavaScript/TypeScript']}>
<Tab value="Python">
```python
import asyncio

# Coroutine function
async def async_operation():
    await asyncio.sleep(1)
    return "Done"

# Creating coroutine
coro = async_operation()  # Coroutine object

# Must await or schedule
result = await coro

# Or gather multiple
results = await asyncio.gather(
    async_operation(),
    async_operation(),
    async_operation()
)
```
</Tab>
<Tab value="JavaScript/TypeScript">
```javascript
// Async function returns Promise
async function asyncOperation() {
  await new Promise(r => setTimeout(r, 1000));
  return "Done";
}

// Creating Promise
const promise = asyncOperation();

// Can await
const result = await promise;

// Or use .then()
promise.then(result => console.log(result));

// Or Promise.all for multiple
const results = await Promise.all([
  asyncOperation(),
  asyncOperation(),
  asyncOperation()
]);
```
</Tab>
</Tabs>

**Key Differences:**
- Python: coroutines must be awaited or scheduled
- JavaScript: Promises can use `.then()` or `await`
- Python: `asyncio.gather()` for multiple
- JavaScript: `Promise.all()` for multiple
- Both support concurrent execution

## Concurrent Execution

<Tabs items={['Python', 'JavaScript/TypeScript']}>
<Tab value="Python">
```python
import asyncio

async def task(name, delay):
    await asyncio.sleep(delay)
    return f"{name} done"

# Sequential (slow)
async def sequential():
    r1 = await task("Task 1", 1)
    r2 = await task("Task 2", 1)
    return [r1, r2]

# Concurrent (fast)
async def concurrent():
    results = await asyncio.gather(
        task("Task 1", 1),
        task("Task 2", 1)
    )
    return results

# Create tasks explicitly
async def with_tasks():
    t1 = asyncio.create_task(task("Task 1", 1))
    t2 = asyncio.create_task(task("Task 2", 1))
    r1 = await t1
    r2 = await t2
    return [r1, r2]
```
</Tab>
<Tab value="JavaScript/TypeScript">
```javascript
async function task(name, delay) {
  await new Promise(r => setTimeout(r, delay));
  return `${name} done`;
}

// Sequential (slow)
async function sequential() {
  const r1 = await task("Task 1", 1000);
  const r2 = await task("Task 2", 1000);
  return [r1, r2];
}

// Concurrent (fast)
async function concurrent() {
  const results = await Promise.all([
    task("Task 1", 1000),
    task("Task 2", 1000)
  ]);
  return results;
}

// With explicit Promises
async function withPromises() {
  const p1 = task("Task 1", 1000);
  const p2 = task("Task 2", 1000);
  const r1 = await p1;
  const r2 = await p2;
  return [r1, r2];
}
```
</Tab>
</Tabs>

**Key Differences:**
- Python: `asyncio.gather()` or `create_task()`
- JavaScript: `Promise.all()` or start promises early
- Python: explicit task creation
- JavaScript: promises start immediately
- Both achieve concurrent execution

## Error Handling in Async

<Tabs items={['Python', 'JavaScript/TypeScript']}>
<Tab value="Python">
```python
async def risky_operation():
    await asyncio.sleep(1)
    raise ValueError("Something went wrong")

# Try-except with await
async def handle_error():
    try:
        result = await risky_operation()
    except ValueError as e:
        print(f"Error: {e}")
        return None

# Gather with errors
async def gather_with_errors():
    results = await asyncio.gather(
        risky_operation(),
        risky_operation(),
        return_exceptions=True  # Don't fail on error
    )
    # results contains exceptions
    for r in results:
        if isinstance(r, Exception):
            print(f"Error: {r}")
```
</Tab>
<tab value="JavaScript/TypeScript">
```javascript
async function riskyOperation() {
  await new Promise(r => setTimeout(r, 1000));
  throw new Error("Something went wrong");
}

// Try-catch with await
async function handleError() {
  try {
    const result = await riskyOperation();
  } catch (error) {
    console.log(`Error: ${error.message}`);
    return null;
  }
}

// Promise.all fails if any promise rejects
async function allWithErrors() {
  try {
    const results = await Promise.all([
      riskyOperation(),
      riskyOperation()
    ]);
  } catch (error) {
    console.log("At least one failed");
  }
}

// Promise.allSettled doesn't fail
async function allSettled() {
  const results = await Promise.allSettled([
    riskyOperation(),
    riskyOperation()
  ]);
  results.forEach(r => {
    if (r.status === 'rejected') {
      console.log(`Error: ${r.reason}`);
    }
  });
}
```
</Tab>
</Tabs>

**Key Differences:**
- Python: `return_exceptions=True` in `gather()`
- JavaScript: `Promise.allSettled()` for error tolerance
- Python: exceptions in results array
- JavaScript: results have `status` and `reason`
- Both use try-catch with await

## Timeouts and Cancellation

<Tabs items={['Python', 'JavaScript/TypeScript']}>
<Tab value="Python">
```python
import asyncio

async def slow_operation():
    await asyncio.sleep(10)
    return "Done"

# Timeout with wait_for
async def with_timeout():
    try:
        result = await asyncio.wait_for(
            slow_operation(),
            timeout=2.0
        )
    except asyncio.TimeoutError:
        print("Operation timed out")

# Manual cancellation
async def with_cancellation():
    task = asyncio.create_task(slow_operation())

    # Cancel after 1 second
    await asyncio.sleep(1)
    task.cancel()

    try:
        await task
    except asyncio.CancelledError:
        print("Task was cancelled")
```
</Tab>
<Tab value="JavaScript/TypeScript">
```javascript
async function slowOperation() {
  await new Promise(r => setTimeout(r, 10000));
  return "Done";
}

// Timeout with Promise.race
async function withTimeout() {
  const timeoutPromise = new Promise((_, reject) =>
    setTimeout(() => reject(new Error("Timeout")), 2000)
  );

  try {
    const result = await Promise.race([
      slowOperation(),
      timeoutPromise
    ]);
  } catch (error) {
    console.log("Operation timed out");
  }
}

// Manual cancellation with AbortController
async function withCancellation() {
  const controller = new AbortController();
  const { signal } = controller;

  // Cancel after 1 second
  setTimeout(() => controller.abort(), 1000);

  try {
    const result = await fetch('https://api.example.com', {
      signal
    });
  } catch (error) {
    if (error.name === 'AbortError') {
      console.log("Request was cancelled");
    }
  }
}
```
</Tab>
</Tabs>

**Key Differences:**
- Python: `asyncio.wait_for()` for timeouts
- JavaScript: `Promise.race()` for timeouts
- Python: `task.cancel()` for cancellation
- JavaScript: `AbortController` for fetch cancellation
- Python has built-in cancellation support

## Async Iterators

<Tabs items={['Python', 'JavaScript/TypeScript']}>
<Tab value="Python">
```python
import asyncio

# Async generator
async def async_range(count):
    for i in range(count):
        await asyncio.sleep(0.1)
        yield i

# Async iteration
async def consume():
    async for value in async_range(5):
        print(value)

# Async comprehension
async def comprehension():
    values = [x async for x in async_range(5)]
    return values

asyncio.run(consume())
```
</Tab>
<Tab value="JavaScript/TypeScript">
```javascript
// Async generator
async function* asyncRange(count) {
  for (let i = 0; i < count; i++) {
    await new Promise(r => setTimeout(r, 100));
    yield i;
  }
}

// Async iteration
async function consume() {
  for await (const value of asyncRange(5)) {
    console.log(value);
  }
}

// No async comprehension, use reduce
async function toArray() {
  const values = [];
  for await (const value of asyncRange(5)) {
    values.push(value);
  }
  return values;
}

consume();
```
</Tab>
</Tabs>

**Key Differences:**
- Python: `async def` with `yield` for generators
- JavaScript: `async function*` for generators
- Python: `async for` loop
- JavaScript: `for await...of` loop
- Python has async comprehensions
- JavaScript requires manual collection

## Async Context Managers

<Tabs items={['Python', 'JavaScript/TypeScript']}>
<Tab value="Python">
```python
import asyncio

class AsyncResource:
    async def __aenter__(self):
        await asyncio.sleep(0.1)
        print("Resource opened")
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await asyncio.sleep(0.1)
        print("Resource closed")

async def use_resource():
    async with AsyncResource() as resource:
        print("Using resource")
        # Automatic cleanup

asyncio.run(use_resource())

# Library example
import aiohttp

async def fetch():
    async with aiohttp.ClientSession() as session:
        async with session.get('https://api.example.com') as resp:
            return await resp.json()
```
</Tab>
<Tab value="JavaScript/TypeScript">
```javascript
// Using statement (TypeScript 5.2+)
class AsyncResource {
  async [Symbol.asyncDispose]() {
    await new Promise(r => setTimeout(r, 100));
    console.log("Resource closed");
  }

  static async create() {
    await new Promise(r => setTimeout(r, 100));
    console.log("Resource opened");
    return new AsyncResource();
  }
}

async function useResource() {
  await using resource = await AsyncResource.create();
  console.log("Using resource");
  // Automatic cleanup
}

// Traditional approach
async function fetch() {
  const response = await fetch('https://api.example.com');
  try {
    return await response.json();
  } finally {
    // Manual cleanup if needed
  }
}
```
</Tab>
</Tabs>

**Key Differences:**
- Python: `async with` statement
- JavaScript: `await using` (TypeScript 5.2+)
- Python: `__aenter__` and `__aexit__` methods
- JavaScript: `Symbol.asyncDispose`
- Python has more mature async context manager support

## Running Multiple Async Functions

<Tabs items={['Python', 'JavaScript/TypeScript']}>
<Tab value="Python">
```python
import asyncio

async def task1():
    await asyncio.sleep(1)
    return "Task 1"

async def task2():
    await asyncio.sleep(2)
    return "Task 2"

# Gather - wait for all
async def gather_all():
    results = await asyncio.gather(task1(), task2())
    return results  # ["Task 1", "Task 2"]

# Wait - more control
async def wait_with_control():
    done, pending = await asyncio.wait(
        [task1(), task2()],
        return_when=asyncio.FIRST_COMPLETED
    )
    # Cancel pending tasks
    for task in pending:
        task.cancel()

# As completed - process as they finish
async def as_completed():
    for coro in asyncio.as_completed([task1(), task2()]):
        result = await coro
        print(f"Got: {result}")
```
</Tab>
<Tab value="JavaScript/TypeScript">
```javascript
async function task1() {
  await new Promise(r => setTimeout(r, 1000));
  return "Task 1";
}

async function task2() {
  await new Promise(r => setTimeout(r, 2000));
  return "Task 2";
}

// Promise.all - wait for all
async function allResults() {
  const results = await Promise.all([task1(), task2()]);
  return results;  // ["Task 1", "Task 2"]
}

// Promise.race - first to complete
async function firstResult() {
  const result = await Promise.race([task1(), task2()]);
  return result;  // "Task 1"
}

// Process as they complete
async function asCompleted() {
  const promises = [task1(), task2()];
  for (const promise of promises) {
    const result = await promise;
    console.log(`Got: ${result}`);
  }
  // Actually processes sequentially, not as completed
}

// True as-completed pattern
async function trueAsCompleted() {
  const promises = [task1(), task2()].map(p =>
    p.then(result => ({ result, done: true }))
  );

  while (promises.length > 0) {
    const { result } = await Promise.race(promises);
    console.log(`Got: ${result}`);
    promises.splice(
      promises.findIndex(p => p === result),
      1
    );
  }
}
```
</Tab>
</Tabs>

**Key Differences:**
- Python: `gather()`, `wait()`, `as_completed()`
- JavaScript: `Promise.all()`, `Promise.race()`
- Python has native "as completed" iteration
- JavaScript requires manual implementation
- Python offers more control over task completion

## Quick Reference

| Concept | Python | JavaScript/TypeScript |
|---------|--------|---------------------|
| Async function | `async def func():` | `async function func() {}` |
| Await | `await coro()` | `await promise()` |
| Run async | `asyncio.run(main())` | `main()` (automatic) |
| Multiple tasks | `asyncio.gather()` | `Promise.all()` |
| Race | `asyncio.wait(..., FIRST_COMPLETED)` | `Promise.race()` |
| Timeout | `asyncio.wait_for()` | `Promise.race()` with timer |
| Cancel | `task.cancel()` | `AbortController` |
| Async iteration | `async for x in y:` | `for await (const x of y)` |
| Async generator | `async def gen():` `yield x` | `async function* gen() {}` |
| Context manager | `async with` | `await using` |
