---
title: Choosing Constraints
description: Limitations force better decisions. Choose them intentionally.
---

Constraints aren't obstacles. They're design tools.

The best products aren't built with unlimited resources. They're built with smart limitations.

## Why constraints matter

Without constraints, you'll:
- Build forever
- Add unnecessary features
- Lose focus
- Never ship

With constraints, you:
- Ship faster
- Focus on what matters
- Make hard choices
- Build better

## Types of constraints

### 1. Time constraints

**Example**: "Launch in 2 weeks"

**Forces:**
- Cut non-essential features
- Use existing tools
- Skip perfection
- Ship and iterate

**Result**: MVP actually ships

### 2. Technical constraints

**Example**: "Use only React and PostgreSQL"

**Forces:**
- No framework hopping
- Deep knowledge of chosen tools
- Faster development
- Less decision fatigue

**Result**: You actually finish

### 3. Scope constraints

**Example**: "Solve for solo users only"

**Forces:**
- No team features
- No permissions
- No collaboration
- Simple data model

**Result**: Simpler product that actually works

### 4. Resource constraints

**Example**: "$0 budget"

**Forces:**
- Use free tiers
- Manual processes
- Smart integrations
- No paid ads

**Result**: Sustainable from day one

## Constraint-driven products

### Example 1: Craigslist

**Constraints**:
- No modern design
- No images (initially)
- Text-only listings
- Minimal features

**Result**: Focused on solving the problem (connecting buyers/sellers) without distraction. Still successful.

### Example 2: Twitter (early days)

**Constraint**: 140 characters

**Forces**:
- Clear, concise communication
- No long-form rambling
- Quick to read
- Easy to scan

**Result**: The constraint was the feature

### Example 3: Instagram (early days)

**Constraints**:
- Photos only (no video initially)
- Square format
- Mobile only

**Forces**:
- Simple interface
- Fast loading
- Clear purpose

**Result**: Massive adoption because it was simple

## How to choose constraints

### 1. Time boxing

Pick a deadline and work backward.

**Bad**: "I'll launch when it's ready"
**Good**: "I'll launch on December 1st"

Forces you to cut scope, not extend timeline.

### 2. Feature limiting

Pick a maximum number of features.

**Bad**: "I'll add features until it's complete"
**Good**: "Launch with exactly 3 features"

Forces prioritization.

### 3. Platform limiting

Pick one platform only.

**Bad**: "Web, iOS, Android, desktop"
**Good**: "Web only" or "iOS only"

**Result**: Ships 3x faster

### 4. User limiting

Pick a narrow audience.

**Bad**: "For everyone who needs productivity tools"
**Good**: "For frontend engineers who work remotely"

**Result**: Clearer product, easier marketing

## The constraint framework

For your product, define:

```
Timeline: [Launch date]
Tech stack: [Max 3-4 tools]
Platform: [One platform only]
Features: [Max 5 for launch]
Audience: [Specific type of user]
Budget: [Dollar amount or $0]
```

**Example**:
```
Timeline: 4 weeks
Tech stack: Next.js, Supabase, Vercel
Platform: Web only
Features: Upload, share, view stats
Audience: Designers sharing prototypes
Budget: $0
```

Clear constraints = clear decisions.

## Constraints as features

Some limitations become differentiators:

### Example: "No meetings" policy

**Constraint**: Async-only communication
**Becomes**: Marketing point for remote teams

### Example: "No AI" products

**Constraint**: Human-only content
**Becomes**: Trust differentiator

### Example: "No tracking"

**Constraint**: Privacy-first approach
**Becomes**: Competitive advantage

Your limitation might be someone's reason to choose you.

## Common constraint mistakes

### 1. Fake constraints

**Fake**: "I need the best hosting"
**Real**: "Free tier works fine for 0 users"

Don't create constraints that don't exist yet.

### 2. Wrong constraints

**Wrong**: "Must use this specific library"
**Right**: "Must launch in 2 weeks"

Constrain outcomes, not methods.

### 3. Too many constraints

**Too many**: "No libraries, no frameworks, no services, pure vanilla JS"
**Right amount**: "Use React, ship in 3 weeks"

Balance constraints with productivity.

## Constraints for side projects

Most side projects fail because there aren't enough constraints.

### Set these constraints:

**Timeline**: "Launch in X weeks or kill it"
- Forces shipping over perfecting
- Prevents endless tinkering

**Scope**: "5 features maximum"
- Forces prioritization
- Prevents scope creep

**Tech**: "Use what I know + max 1 new thing"
- Learn one thing, not five
- Ship faster

**Platform**: "Web only" or "Mobile only"
- No multi-platform complexity
- Focus on one experience

## For frontend engineers

### Technical constraint examples

**Build time**: "Max 30 seconds build time"
- Forces code splitting
- Prevents bloat
- Better DX

**Bundle size**: "Max 100kb JS"
- Forces tree shaking
- Prevents over-importing
- Better performance

**Dependencies**: "Max 10 npm packages"
- Forces vanilla solutions
- Less supply chain risk
- Faster installs

These aren't restrictions. They're design principles.

## Exercise

For your current/next project, write:

1. **Timeline**: When will you launch?
2. **Tech stack**: What 3-4 tools will you use?
3. **Platform**: Web, mobile, or desktop? Pick one.
4. **Features**: List 5 max for launch
5. **Audience**: Who specifically is this for?

If you can't define these, your constraints are too loose.

## The paradox

More options = slower decisions = less output

Fewer options = faster decisions = more output

**Unlimited**: Spend weeks choosing tools, never ship

**Constrained**: Spend hours choosing, ship in weeks

Constraints aren't limitations. They're liberation.

---

Next: How to ship and learn from real users.
